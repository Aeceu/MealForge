import json
import os
import random

import google.generativeai as genai
import joblib as joblib
import pandas as pd
from flask import Blueprint, jsonify, request
from model.NLP import get_recipe_details_top5, get_similar_top5

genai.configure(api_key=os.getenv("AI_API_KEY"))
generate_bp = Blueprint("generate", __name__)

base_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))

loaded_vectorizer = joblib.load(open(os.path.join(base_dir, 'dataset', 'nlp_vectorizer.pkl'), 'rb'))
loaded_tfidf_matrix = joblib.load(open(os.path.join(base_dir, 'dataset', 'nlp_tfidf_matrix.pkl'), 'rb'))

filtered_recipes = pd.read_csv(os.path.join(base_dir, 'dataset', 'recipes_data_all.csv'), usecols=['title', 'ingredients', 'directions', 'NER'])

model = genai.GenerativeModel("gemini-1.5-flash")

@generate_bp.route("/generate/recipe", methods=["POST"])
def generate():
    data = request.get_json()

    main_ingredients = data.get("main_ingredients")
    seasonings = data.get("seasonings")
    ingredients = main_ingredients + seasonings

    servings = data.get("servings")
    serve_hot_or_cold = data.get("serve_hot_or_cold")
    cuisine_type = data.get("cuisine_type")
    user_preference = data.get("user_preference")
    difficulty = data.get("difficulty")

    similar_top5_indices = get_similar_top5(loaded_vectorizer, loaded_tfidf_matrix, ingredients)
    recommended_recipes = get_recipe_details_top5(filtered_recipes, similar_top5_indices)

    top_recipe = recommended_recipes.iloc[random.choice(range(5))]
    top_recipe_str = f"Title: {top_recipe['title']}, Ingredients: {top_recipe['ingredients']}, Directions: {top_recipe['directions']}, NER: {top_recipe['NER']}"
    user_preference_str = ', '.join(user_preference)

    response = model.generate_content(f"""
      Create a new recipe that incorporates the following ingredients provided by the user:
        - Main Ingredients: {', '.join(main_ingredients)}
        - Seasonings: {', '.join(seasonings)}
        - Servings: {servings}
        - Serve Hot or Cold: {serve_hot_or_cold}
        - Cuisine Type: {cuisine_type}
        - difficulty level: {difficulty}

      Use the recipe generated by NLP as a base, but update it with additional fields and information if it lacks any required attributes.
      If the base recipe, {top_recipe_str}, does not align with the specified user ingredients, create a modified recipe that exactly matches the user input.
      Please make sure to use to the following user preferences: {user_preference_str}.
      The output should be in valid JSON format with the following structure:
      {{
        "name": "Title of the recipe, as a string with a maximum length of 250 characters.",
        "ingredients": [
            {{
                "name": "The exact word name of each ingredient from the user-provided input. Don't use comma symbol in name",
                "measurement": "The exact quantity of each ingredient for {servings} servings. Don't use comma symbol in measurements"
            }}
        ],
        "instructions": [
            "Step 1: Detailed first step of the recipe. Don't use comma symbol in each steps",
            "Step 2: Detailed second step of the recipe. Don't use comma symbol in each steps",
            "...additional steps."
        ],
        "type_of_cuisine": "Cuisine type (e.g., Italian, Mexican), provided as a string with up to 250 characters.",
        "nutrient_counts": [
          {{
              "name":"The exact word name of nutrients (e.g., calories,carbs), provided as a string. Don't use comma symbol in name",
              "measurement":"The exact amount of the nutrients for {servings} servings (e.g., 86 calories) in numbers only. Don't use comma symbol in measurement"
          }}
        ],
        "serve_hot_or_cold": "Specify if the recipe is best served hot or cold, as a string with up to 50 characters. Only return the word "Hot" or "Cold",
        "cooking_time": "Integer representing total cooking time in minutes. Only return the number",
        "benefits": "Optional text noting health benefits, if any.",
        "serve_for": "Number of servings ({servings}). Only return the number.",
        "difficulty": "Difficulty level of cooking the recipe ({difficulty}). Only return wether easy, medium or hard."
      }}

      Ensure the instructions are provided in a clear step-by-step array format, and that the recipe exactly aligns with the user-provided ingredients.
  """)

    try:
        json_response = response.text.replace("```json", "").replace("```", "").strip()
        print(json_response)
        json_data = json.loads(json_response)
        return jsonify(json_data)
    except json.JSONDecodeError:
        return jsonify({"error": "Failed to parse JSON from AI response.", "response": response.generated_text}), 500
